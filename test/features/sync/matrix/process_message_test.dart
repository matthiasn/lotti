import 'dart:convert';
import 'dart:io';

import 'package:flutter_test/flutter_test.dart';
import 'package:lotti/classes/entry_link.dart';
import 'package:lotti/database/database.dart';
import 'package:lotti/features/sync/matrix/matrix_service.dart';
import 'package:lotti/features/sync/matrix/process_message.dart';
import 'package:lotti/get_it.dart';
import 'package:lotti/services/db_notification.dart';
import 'package:lotti/services/logging_service.dart';
import 'package:matrix/matrix.dart';
import 'package:mocktail/mocktail.dart';

import '../../../test_utils/sealed_class_helpers.dart';

// Mock classes
class MockEvent extends Mock implements Event {}

class MockMatrixService extends Mock implements MatrixService {}

class MockJournalDb extends Mock implements JournalDb {}

class MockUpdateNotifications extends Mock implements UpdateNotifications {}

class MockLoggingService extends Mock implements LoggingService {}

class MockEntryLink extends Mock implements EntryLink {
  MockEntryLink(
    this.mockFromId,
    this.mockToId,
  );

  final String mockFromId;
  final String mockToId;

  @override
  String get fromId => mockFromId;

  @override
  String get toId => mockToId;
}

void main() {
  late MockEvent mockEvent;
  late MockMatrixService mockMatrixService;
  late MockJournalDb mockJournalDb;
  late MockUpdateNotifications mockUpdateNotifications;
  late MockLoggingService mockLoggingService;
  late Directory fakeDirectory;

  const eventId = 'event-id-123';
  final now = DateTime.now();

  setUpAll(() {
    registerFallbackValue(StackTrace.empty);
    registerFallbackValue(FakeJournalEntity());
    // We can't directly create these, so we'll just mock them
    registerFallbackValue(MockEntryLink('mock-from', 'mock-to'));
    registerFallbackValue(<String>{});
  });

  setUp(() {
    mockEvent = MockEvent();
    mockMatrixService = MockMatrixService();
    mockJournalDb = MockJournalDb();
    mockUpdateNotifications = MockUpdateNotifications();
    mockLoggingService = MockLoggingService();
    fakeDirectory = Directory('/fake/path');

    // Set up default mocks
    when(() => mockEvent.eventId).thenReturn(eventId);
    when(() => mockEvent.originServerTs).thenReturn(now);

    // Setup the GetIt instance and register services with cascade
    getIt
      ..reset()
      ..registerSingleton<JournalDb>(mockJournalDb)
      ..registerSingleton<UpdateNotifications>(mockUpdateNotifications)
      ..registerSingleton<LoggingService>(mockLoggingService)
      ..registerSingleton<Directory>(fakeDirectory);
  });

  tearDown(getIt.reset);

  group('processMatrixMessage', () {
    test('should handle malformed JSON and log exception', () async {
      // Valid base64 string with invalid JSON structure for SyncMessage
      final validBase64 = base64.encode(utf8.encode('{"invalid": "json"}'));
      when(() => mockEvent.text).thenReturn(validBase64);

      await processMatrixMessage(
        event: mockEvent,
        service: mockMatrixService,
        overriddenJournalDb: mockJournalDb,
      );

      // Should capture exception for invalid JSON
      verify(
        () => mockLoggingService.captureException(
          any<Object>(),
          domain: 'MATRIX_SERVICE',
          subDomain: 'processMessage',
          stackTrace: any<StackTrace>(named: 'stackTrace'),
        ),
      ).called(1);
    });

    test('should log exceptions for invalid base64', () async {
      // Simulate an exception during processing
      when(() => mockEvent.text).thenReturn('invalid-base64-string');

      // Run the function being tested
      await processMatrixMessage(
        event: mockEvent,
        service: mockMatrixService,
        overriddenJournalDb: mockJournalDb,
      );

      // Verify error logging
      verify(
        () => mockLoggingService.captureException(
          any<Object>(),
          domain: 'MATRIX_SERVICE',
          subDomain: 'processMessage',
          stackTrace: any<StackTrace>(named: 'stackTrace'),
        ),
      ).called(1);
    });

    // Note: Due to the complex nature of the SyncMessage class which is generated by freezed,
    // and the direct file system dependencies in the journalEntity handler,
    // we're only testing the error handling scenarios which are more straightforward.
    //
    // To properly test the different message type handlers, the code would need to be refactored to:
    // 1. Use dependency injection for file operations
    // 2. Make the process_message.dart code more testable with interfaces
    // 3. Possibly create test factory methods for the SyncMessage types
  });
}
